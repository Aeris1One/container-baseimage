#!/usr/bin/python -u
import os, os.path, sys, stat, signal, errno, argparse, time, re, json, yaml, ast, socket, shutil, pwd, grp

KILL_PROCESS_TIMEOUT = 5
KILL_ALL_PROCESSES_TIMEOUT = 5

LOG_LEVEL_ERROR = 1
LOG_LEVEL_WARN  = 2
LOG_LEVEL_INFO  = 3
LOG_LEVEL_DEBUG = 4
LOG_LEVEL_TRACE = 5

SHENV_NAME_WHITELIST_REGEX = re.compile('[^\w\-_\.]')

yamlExtensions = ('.yaml', '.yaml.setup')
jsonExtensions = ('.json', '.json.setup')
setupExtensions = ('.yaml.setup', '.json.setup')

log_level = None
copy_service = None

environ_backup = dict(os.environ)

terminated_child_processes = {}

class AlarmException(Exception):
	pass

def error(message):
	if log_level >= LOG_LEVEL_ERROR:
		sys.stderr.write("*** %s\n" % message)

def warn(message):
	if log_level >= LOG_LEVEL_WARN:
		sys.stderr.write("*** %s\n" % message)

def info(message):
	if log_level >= LOG_LEVEL_INFO:
		sys.stderr.write("*** %s\n" % message)

def debug(message):
	if log_level >= LOG_LEVEL_DEBUG:
		sys.stderr.write("*** %s\n" % message)

def trace(message):
	if log_level >= LOG_LEVEL_TRACE:
		sys.stderr.write("*** %s\n" % message)

def debug_env_dump():
		debug("--- Environment dump ---")
		for name, value in os.environ.items():
			debug(name + " = " +  value)
		debug("------------------------")

def ignore_signals_and_raise_keyboard_interrupt(signame):
	signal.signal(signal.SIGTERM, signal.SIG_IGN)
	signal.signal(signal.SIGINT, signal.SIG_IGN)
	raise KeyboardInterrupt(signame)

def raise_alarm_exception():
	raise AlarmException('Alarm')

def listdir(path):
	try:
		result = os.stat(path)
	except OSError:
		return []
	if stat.S_ISDIR(result.st_mode):
		return sorted(os.listdir(path))
	else:
		return []

def is_exe(path):
	try:
		return os.path.isfile(path) and os.access(path, os.X_OK)
	except OSError:
		return False

def xstr(s):
    if s is None:
        return ''
    return str(s)

def set_env_hostname_to_etc_hosts():
	try:
		if "HOSTNAME" in os.environ:
			with open('/etc/hostname', 'r') as f:
				etc_hostname = f.readline().rstrip()

			ip_address = socket.gethostbyname(etc_hostname)

			if os.environ["HOSTNAME"] != etc_hostname:
				with open("/etc/hosts", "a") as myfile:
					myfile.write(ip_address+" "+os.environ["HOSTNAME"]+"\n")
	except:
		debug("set_env_hostname_to_etc_hosts failed at some point...")

def python_dict_to_bash_envvar(name, python_dict):

		for value in python_dict:
			python_to_bash_envvar(name+"_KEY", value)
			python_to_bash_envvar(name+"_VALUE", python_dict.get(value))

		values = "#COMPLEX_BASH_ENV:ROW: "+name+"_KEY "+name+"_VALUE"
		os.environ[name] = xstr(values)
		debug("python2bash : set : " + name + " = "+ os.environ[name])

def python_list_to_bash_envvar(name, python_list):

		values="#COMPLEX_BASH_ENV:TABLE:"

		i=1
		for value in python_list:
			child_name = name + "_ROW_" + str(i)
			values += " " + child_name
			python_to_bash_envvar(child_name, value)
			i = i +1

		os.environ[name] = xstr(values)
		debug("python2bash : set : " + name + " = "+ os.environ[name])

def python_to_bash_envvar(name, value):

		try:
				value = ast.literal_eval(value)
		except:
				pass

		if isinstance(value, list):
				python_list_to_bash_envvar(name,value)

		elif isinstance(value, dict):
				python_dict_to_bash_envvar(name,value)

		else:
				os.environ[name] = xstr(value)
				debug("python2bash : set : " + name + " = "+ os.environ[name])

def decode_python_envvars():
	_environ = dict(os.environ)
	for name, value in _environ.items():
		if value.startswith("#PYTHON2BASH:") :
			value = value.replace("#PYTHON2BASH:","",1)
			python_to_bash_envvar(name, value)

def decode_json_envvars():
	_environ = dict(os.environ)
	for name, value in _environ.items():
		if value.startswith("#JSON2BASH:") :
			value = value.replace("#JSON2BASH:","",1)
			try:
				value = json.loads(value)
				python_to_bash_envvar(name,value)
			except:
				os.environ[name] = xstr(value)
				debug("failed to parse : " + xstr(value))
				debug("set : " + name + " = "+ os.environ[name])

def decode_envvars():
	decode_json_envvars()
	decode_python_envvars()

def generic_import_envvars(path, override_existing_environment):
	if not os.path.exists(path):
		debug("generic_import_envvars "+ path+ " don't exists")
		return
	new_env = {}
	for envfile in listdir(path):
		filePath=path + "/" + envfile
		if os.path.isfile(filePath) and "." not in envfile:
			name = os.path.basename(envfile)
			with open(filePath, "r") as f:
				# Text files often end with a trailing newline, which we
				# don't want to include in the env variable value. See
				# https://github.com/phusion/baseimage-docker/pull/49
				value = re.sub('\n\Z', '', f.read())
			new_env[name] = value
			debug("import " + name + " from " + filePath + " --- ")

	for name, value in new_env.items():
		if override_existing_environment or not name in os.environ:
			os.environ[name] = value
			debug("set : " + name + " = "+ os.environ[name])
		else:
			debug("ignore : " + name + " = " + xstr(value) + " (keep " + name + " = " + os.environ[name] + " )")

def import_run_envvars():
	clear_environ()
	generic_import_envvars("/container/run/environment", True)

def import_envvars():
	generic_import_envvars("/container/environment", False)
	generic_import_envvars("/container/environment/setup", False)

def export_run_envvars(to_dir = True):
	if to_dir and not os.path.exists("/container/run/environment"):
		warn("export_run_envvars /container/run/environment don't exists")
		return
	shell_dump = ""
	for name, value in os.environ.items():
		if name in ['USER', 'GROUP', 'UID', 'GID', 'SHELL']:
			continue
		if to_dir:
			with open("/container/run/environment/" + name, "w") as f:
				f.write(value)
			debug("export " + name + " to /container/run/environment/" + name + " --- ")
		shell_dump += "export " + sanitize_shenvname(name) + "=" + shquote(value) + "\n"

	with open("/container/run/environment.sh", "w") as f:
		f.write(shell_dump)
	debug("export /container/run/environment.sh --- ")

def create_run_envvars():
		set_service_dir_env()
		set_log_level_env()
		import_envvars()
		import_env_files()
		decode_envvars()
		export_run_envvars()

def clear_run_envvars():
	try:
		shutil.rmtree('/container/run/environment')
		os.makedirs('/container/run/environment')
		os.chmod('/container/run/environment', 700)
	except:
		warn("clear_run_envvars failed at some point...")

def print_env_files_order(fileExtensions):

	if not os.path.exists("/container/environment"):
		warn("print_env_files_order /container/environment don't exists")
		return

	to_print = 'Caution: previously defined variables will not be overriden.\n'

	file_found = False
	for subdir, dirs, files in sorted(os.walk("/container/environment")):
		for file in files:
			filepath = subdir + os.sep + file
			if filepath.endswith(fileExtensions):
				file_found = True
				filepath = subdir + os.sep + file
				to_print+=filepath + '\n'

	if file_found:
		to_print+='\nTo see how this files are processed and environment variables values,\n'
		to_print+='run this image with command \'/container/tool/run --loglevel debug\''

		info('Environment files will be proccessed in this order : \n' + to_print)

def import_env_files():

	if not os.path.exists("/container/environment"):
		warn("import_env_files /container/environment don't exists")
		return

	fileExtensions = yamlExtensions + jsonExtensions
	print_env_files_order(fileExtensions)

	for subdir, dirs, files in sorted(os.walk("/container/environment")):
		for file in files:
			if file.endswith(fileExtensions):
				filepath = subdir + os.sep + file

				try:
					with open(filepath, "r") as f:

						debug("--- process file : " + filepath+ " ---")

						if file.endswith(yamlExtensions):
							env_vars = yaml.load(f)

						elif file.endswith(jsonExtensions):
							env_vars = json.load(f)

						for name, value in env_vars.items():
							if not name in os.environ:
								if isinstance(value, list) or isinstance(value, dict):
									os.environ[name] = '#PYTHON2BASH:' + xstr(value)
								else:
									os.environ[name] = xstr(value)
								debug("set : " + name + " = "+ os.environ[name])
							else:
								debug("ignore : " + name + " = " + xstr(value) + " (keep " + name + " = " + os.environ[name] + " )")
				except:
					info('failed to parse: ' + filepath)

def remove_setup_env_files():

	if os.path.isdir('/container/environment/setup'):
		shutil.rmtree('/container/environment/setup')

	if not os.path.exists("/container/environment"):
		warn("remove_setup_env_files /container/environment don't exists")
		return

	for subdir, dirs, files in sorted(os.walk("/container/environment")):
		for file in files:
			filepath = subdir + os.sep + file
			if filepath.endswith(setupExtensions):
				os.remove(filepath)


def restore_environ():
	clear_environ()
	debug("--- Restore initial environment ---")
	os.environ.update(environ_backup)

def clear_environ():
	debug("--- Clear existing environment ---")
	os.environ.clear()

def set_startup_scripts_env():
	info("Set environment for startup scripts")
	clear_run_envvars() # clear previous environment
	create_run_envvars() # create run envvars with all env files

def set_process_env():
	info("Set environment for container process")
	remove_setup_env_files()
	clear_run_envvars()

	restore_environ()
	create_run_envvars() # recreate env var without setup files

def setup_run_directories():

	directories = ('/container/run/process', '/container/run/startup', '/container/run/state', '/container/run/environment')
	for directory in directories:
		if not os.path.exists(directory):
		    	os.makedirs(directory)

			if directory == "/container/run/environment":
				os.chmod(directory, 700)

	if not os.path.exists('/container/run/environment.sh'):
		open('/container/run/environment.sh', 'a').close()
		os.chmod('/container/run/environment.sh', 640)
		uid = pwd.getpwnam("root").pw_uid
		gid = grp.getgrnam("docker_env").gr_gid
		os.chown('/container/run/environment.sh', uid, gid)

	if state_is_first_start():

		if copy_service:
			copy_service_to_run_dir()

		set_service_dir_env()

		base_path = os.environ['SERVICE_DIR']
		nb_service = len(listdir(base_path))

		if nb_service > 0 :
			info("Search service in SERVICE_DIR = "+base_path+" :")
			for d in listdir(base_path):
				d_path = base_path + '/' + d
				if os.path.isdir(d_path):
					if is_exe(d_path + '/container-start.sh'):
						info('link ' + d_path + '/container-start.sh to /container/run/startup/' + d)
						os.symlink(d_path + '/container-start.sh', '/container/run/startup/' + d)

					if is_exe(d_path + '/process.sh'):
						info('link ' + d_path + '/process.sh to /container/run/process/' + d + '/run')
						os.makedirs('/container/run/process/' + d)
						os.symlink(d_path + '/process.sh', '/container/run/process/' + d + '/run')

def set_service_dir_env():
	if copy_service:
		os.environ['SERVICE_DIR'] = '/container/run/service'
	else:
		os.environ['SERVICE_DIR'] = '/container/service'
	debug("set : SERVICE_DIR = " + os.environ['SERVICE_DIR'])

def set_log_level_env():
	os.environ['LOG_LEVEL'] = log_level
	debug("set : LOG_LEVEL = " + os.environ['LOG_LEVEL'])

def copy_service_to_run_dir():
	info("Copy /container/service to /container/run/service")
	shutil.copytree("/container/service", "/container/run/service")

def state_set_first_start_done():
	open("/container/run/state/first-start-done", 'a').close()

def state_is_first_start():
	return os.path.exists('/container/run/state/first-start-done') == False

def state_set_start_done():
	open("/container/run/state/start-done", 'a').close()

def state_reset_start_done():
	try:
	    os.remove("/container/run/state/start-done")
	except OSError:
	    pass

def is_multiple_process_image():
	return len(listdir("/container/run/process/")) > 1

def is_single_process_image():
	return len(listdir("/container/run/process/")) == 1

def get_single_process():
	for p in listdir("/container/run/process/"):
		return '/container/run/process/' + p + '/run'

def is_runit_installed():
	return os.path.exists('/sbin/runit')

_find_unsafe = re.compile(r'[^\w@%+=:,./-]').search

def shquote(s):
	"""Return a shell-escaped version of the string *s*."""
	if not s:
		return "''"
	if _find_unsafe(s) is None:
		return s

	# use single quotes, and put single quotes into double quotes
	# the string $'b is then quoted as '$'"'"'b'
	return "'" + s.replace("'", "'\"'\"'") + "'"

def sanitize_shenvname(s):
	return re.sub(SHENV_NAME_WHITELIST_REGEX, "_", s)

# Waits for the child process with the given PID, while at the same time
# reaping any other child processes that have exited (e.g. adopted child
# processes that have terminated).
def waitpid_reap_other_children(pid):
	global terminated_child_processes

	status = terminated_child_processes.get(pid)
	if status:
		# A previous call to waitpid_reap_other_children(),
		# with an argument not equal to the current argument,
		# already waited for this process. Return the status
		# that was obtained back then.
		del terminated_child_processes[pid]
		return status

	done = False
	status = None
	while not done:
		try:
			# https://github.com/phusion/baseimage-docker/issues/151#issuecomment-92660569
			this_pid, status = os.waitpid(pid, os.WNOHANG)
			if this_pid == 0:
				this_pid, status = os.waitpid(-1, 0)
			if this_pid == pid:
				done = True
			else:
				# Save status for later.
				terminated_child_processes[this_pid] = status
		except OSError as e:
			if e.errno == errno.ECHILD or e.errno == errno.ESRCH:
				return None
			else:
				raise
	return status

def stop_child_process(name, pid, signo = signal.SIGTERM, time_limit = KILL_PROCESS_TIMEOUT):
	info("Shutting down %s (PID %d)..." % (name, pid))
	try:
		os.kill(pid, signo)
	except OSError:
		pass
	signal.alarm(time_limit)
	try:
		try:
			waitpid_reap_other_children(pid)
		except OSError:
			pass
	except AlarmException:
		warn("%s (PID %d) did not shut down in time. Forcing it to exit." % (name, pid))
		try:
			os.kill(pid, signal.SIGKILL)
		except OSError:
			pass
		try:
			waitpid_reap_other_children(pid)
		except OSError:
			pass
	finally:
		signal.alarm(0)

def run_command_killable(*argv):
	filename = argv[0]
	status = None
	debug_env_dump()
	pid = os.spawnvp(os.P_NOWAIT, filename, argv)
	try:
		status = waitpid_reap_other_children(pid)
	except BaseException as s:
		warn("An error occurred. Aborting.")
		stop_child_process(filename, pid)
		raise
	if status != 0:
		if status is None:
			error("%s exited with unknown status\n" % filename)
		else:
			error("%s failed with status %d\n" % (filename, os.WEXITSTATUS(status)))
		sys.exit(1)

def run_command_killable_and_import_run_envvars(*argv):
	run_command_killable(*argv)
	import_run_envvars()
	export_run_envvars(False)

def kill_all_processes(time_limit):
	info("Killing all processes...")
	try:
		os.kill(-1, signal.SIGTERM)
	except OSError:
		pass
	signal.alarm(time_limit)
	try:
		# Wait until no more child processes exist.
		done = False
		while not done:
			try:
				os.waitpid(-1, 0)
			except OSError as e:
				if e.errno == errno.ECHILD:
					done = True
				else:
					raise
	except AlarmException:
		warn("Not all processes have exited in time. Forcing them to exit.")
		try:
			os.kill(-1, signal.SIGKILL)
		except OSError:
			pass
	finally:
		signal.alarm(0)

def run_startup_files():
	# Run /container/run/startup/*
	for name in listdir("/container/run/startup"):
		filename = "/container/run/startup/" + name
		if is_exe(filename):
			info("Running %s..." % filename)
			run_command_killable_and_import_run_envvars(filename)

	# Run /container/run/startup.sh.
	if is_exe("/container/run/startup.sh"):
		info("Running /container/run/startup.sh...")
		run_command_killable_and_import_run_envvars("/container/run/startup.sh")

def start_runit():
	info("Booting runit daemon...")
	debug_env_dump()
	pid = os.spawnl(os.P_NOWAIT, "/usr/bin/runsvdir", "/usr/bin/runsvdir",
		"-P", "/container/run/process")
	info("Runit started as PID %d" % pid)
	return pid

def wait_for_runit_or_interrupt(pid):
	try:
		status = waitpid_reap_other_children(pid)
		return (True, status)
	except KeyboardInterrupt:
		return (False, None)

def shutdown_runit_services():
	debug("Begin shutting down runit services...")
	os.system("/usr/bin/sv down /container/run/process/*")

def wait_for_runit_services():
	debug("Waiting for runit services to exit...")
	done = False
	while not done:
		done = os.system("/usr/bin/sv status /container/run/process/* | grep -q '^run:'") != 0
		if not done:
			time.sleep(0.1)

def main(args):

	setup_run_directories()

	if state_is_first_start():
		set_env_hostname_to_etc_hosts()

	if not args.skip_startup_files:
		set_startup_scripts_env()
		run_startup_files()

	set_process_env()

	state_set_start_done()
	state_set_first_start_done()

	runit_exited = False
	exit_code = None

	# No main command
	# if it's a multiple process image we run runit normaly
	# if it's a single process image we run only the process (runit is not installed anyway...)
	# if no process we run bash
	if len(args.main_command) == 0 and not is_multiple_process_image():
		if is_single_process_image():
			args.main_command = [get_single_process()]
		else:
			args.main_command = ['bash']

	if not is_runit_installed():
		args.skip_runit = True

	if not args.skip_runit:
		runit_pid = start_runit()
	try:
		exit_status = None
		if len(args.main_command) == 0:
			runit_exited, exit_code = wait_for_runit_or_interrupt(runit_pid)
			if runit_exited:
				if exit_code is None:
					info("Runit exited with unknown status")
					exit_status = 1
				else:
					exit_status = os.WEXITSTATUS(exit_code)
					info("Runit exited with status %d" % exit_status)
		else:
			info("Running %s..." % " ".join(args.main_command))
			debug_env_dump()
			pid = os.spawnvp(os.P_NOWAIT, args.main_command[0], args.main_command)
			try:
				exit_code = waitpid_reap_other_children(pid)
				if exit_code is None:
					info("%s exited with unknown status." % args.main_command[0])
					exit_status = 1
				else:
					exit_status = os.WEXITSTATUS(exit_code)
					info("%s exited with status %d." % (args.main_command[0], exit_status))
			except KeyboardInterrupt:
				stop_child_process(args.main_command[0], pid)
				raise
			except BaseException as s:
				warn("An error occurred. Aborting.")
				stop_child_process(args.main_command[0], pid)
				raise
		sys.exit(exit_status)
	finally:
		if not args.skip_runit:
			shutdown_runit_services()
			if not runit_exited:
				stop_child_process("runit daemon", runit_pid)
			wait_for_runit_services()

state_reset_start_done()

# Parse options.
parser = argparse.ArgumentParser(description = 'Initialize the system.')
parser.add_argument('main_command', metavar = 'MAIN_COMMAND', type = str, nargs = '*',
	help = 'The main command to run. (default: runit for multiple process image, image process for single process image otherwise bash)')
parser.add_argument('--skip-startup-files', dest = 'skip_startup_files',
	action = 'store_const', const = True, default = False,
	help = 'Skip running /container/run/startup/* and /container/run/startup.sh')
parser.add_argument('--skip-runit', dest = 'skip_runit',
	action = 'store_const', const = True, default = False,
	help = 'Do not run runit services')
parser.add_argument('--no-kill-all-on-exit', dest = 'kill_all_on_exit',
	action = 'store_const', const = False, default = True,
	help = 'Don\'t kill all processes on the system upon exiting')
parser.add_argument('--loglevel', type=str, choices=["none","error","warning","info","debug","trace"], dest = 'log_level', default = "info",
	help = 'Log level (default: info)')
parser.add_argument('--copy-service', dest = 'copy_service',
	action = 'store_const', const = True, default = False,
	help = 'Copy /container/service to /container/run/service')

args = parser.parse_args()

log_level_switcher = {"none": 0,"error": 1,"warning": 2,"info": 3,"debug": 4, "trace": 5}
log_level = log_level_switcher.get(args.log_level)

copy_service = args.copy_service

if args.skip_runit and len(args.main_command) == 0:
	error("When --skip-runit is given, you must also pass a main command.")
	sys.exit(1)

# Run main function.
signal.signal(signal.SIGTERM, lambda signum, frame: ignore_signals_and_raise_keyboard_interrupt('SIGTERM'))
signal.signal(signal.SIGINT, lambda signum, frame: ignore_signals_and_raise_keyboard_interrupt('SIGINT'))
signal.signal(signal.SIGALRM, lambda signum, frame: raise_alarm_exception())

try:
	main(args)
except KeyboardInterrupt:
	warn("Init system aborted.")
	exit(2)
finally:
	if args.kill_all_on_exit:
		kill_all_processes(KILL_ALL_PROCESSES_TIMEOUT)
